\documentclass[letter]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{stmaryrd}

%% Sets page size and margins
\usepackage[top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
%\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{array}
\usepackage[shortlabels]{enumitem}
\usepackage[final]{pdfpages}
\usepackage[normalem]{ulem}
\usepackage{cancel}
\usepackage{xspace,mdwlist}
\usepackage{algorithmic}
\usepackage{mathtools}
\usetikzlibrary{calc}

\usepackage{courier} %% Sets font for listing as Courier.
\usepackage{listings, xcolor}
\lstset{
tabsize = 4, %% set tab space width
showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
numbers = left, %% display line numbers on the left
commentstyle = \color{green}, %% set comment color
keywordstyle = \color{blue}, %% set keyword color
stringstyle = \color{red}, %% set string color
rulecolor = \color{black}, %% set frame color to avoid being affected by text color
basicstyle = \small \ttfamily , %% set listing font and size
breaklines = true, %% enable line breaking
numberstyle = \tiny,
}



\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

\newtheorem{theorem}{Theorem}[section]
\newtheorem*{claim}{Claim}
\DeclareMathOperator*{\argmin}{\arg\!\min}

\def\coursename{CS 201: Data Structures}

%% make title box
\newcommand{\header}[1]{%
	\begin{center}
		\fbox{
			\begin{minipage}{6in}
				\textbf{\coursename} \hfill       \\
				\textit{#1} \hfill \textit{\today}
			\end{minipage}
		}
	\end{center}
	\vspace*{4mm}
}

\def\problem#1#2#3{
\fbox{
\begin{minipage}{0.8\textwidth}
{\sc #1:}

\begin{description*}
\item[Given:] #2
\item[Find:] #3
\end{description*}
\end{minipage}
}
\bigskip
}


\begin{document}

\header{Week 3}

\begin{enumerate}[1.] 
    
    \item Suppose we have a singly linked list:
    
    head -> [3 -]-> [10 -]-> [17 -]-> [25 -]-> null 
    
    What is the effect of the following code fragment on the linked list? (Might be helpful to draw a diagram).
    \begin{itemize}
        \item [(a)] \begin{verbatim}
        Node<Integer> nodeRef = head.next;
        nodeRef.data = 50;

        \end{verbatim}
        \item [(b)] \begin{verbatim}
        Node<Integer> nodeRef = head.next;
        head.next = nodeRef.next;

        \end{verbatim}
        \item [(c)] \begin{verbatim}
        Node<Integer> nodeRef = new Node<Integer>(19);
        head = nodeRef;

        \end{verbatim}
        
    \end{itemize}
    
    \item Write the following static method: (Question from Koffman and Elliot)
    
    /** Replaces each occurrence of oldItem in aList with newItem. */
    public static void replace(ArrayList<String> aList, String oldItem,
    String newItem). Remember to use ArrayList functions when you can.

    \begin{lstlisting}[language = Java , frame = trBL , firstnumber = 0 , escapeinside={(*@}{@*)}]
    public static void replace(ArrayList<String> aList, String oldItem,
    String newItem) {
        for (_______;_____________;_______) {
            if (__________________________________) {




                
            }
        }
        return aList;
    }
    \end{lstlisting}
    
    \newpage

    \item In the class SimpleLinkedList, write a function indexOf(E item) which returns the smallest index of the linked list that contains the item.

    \begin{lstlisting}[language = Java , frame = trBL , firstnumber = 0 , escapeinside={(*@}{@*)}]
    public ____ indexOf(____ item) {
        int indexToReturn = 0;
        Node<E> temp = head;
        
        while (temp != null) {
            if ((temp.data).equals(item)) {
                _________
            }
            ______________
            ______________
        }

        //TODO: what should we do if we loop through the entire list and cant find item?
        if (______________) {
            return -1;
        }
        return _____________;
    
    
    \end{lstlisting}
    
    \item In the class SimpleLinkedList, write a function mergeList(SimpleLinkedList<E> newList, int pos) which adds a linked list newList into the current linked list at position pos. 

    \begin{lstlisting}[language = Java , frame = trBL , firstnumber = 0 , escapeinside={(*@}{@*)}]
    public ____ mergeList(SimpleLinkedList<E> newList, int pos) {
        if (pos < 0 || pos > numItems || newList.numItems == 0) { throw new IndexOutOfBoundsException(); }
        if (numItems == 0) {
            Node<E> temp = newList.head;
            while (temp.next != null) {
                temp = temp.next;
                numItems++;
            }
            temp.next = head;
            head = newList.head;
        } else {
            Node<E> temp = head;
            int i = 0;
            while (                ) {
                //Your code here



                
                i++;
            }
            //TODO: Connect the head of the new list at the correct position of the old list

            

            //TODO: Traverse through the newList to get to the tail
            while (               ) {

                
            }

            //TODO: Connect the tail of the newList to the correct position of the old list. 


        }
    }
    \end{lstlisting}

    
    \item The following function is supposed to remove an item at index pos from a single-linked list. Can you identify four problems with this function and fix them?

        
    \begin{lstlisting}[language = Java , frame = trBL , firstnumber = 0 , escapeinside={(*@}{@*)}]
    public E remove(int pos) {
        // If we're removing head, do something specific:
        if (pos == 0) {
            E toReturn = head.data;
            head = head.next;
            numItems--;
            return toReturn;
        } else {
            Node<E> temp = head;
            for (int i = 0; i < pos; i++) {
                temp = temp.next;
            }
            E toReturn = temp.data;
            temp.next = temp.next.next;
            numItems--;
            return toReturn;
        }
    }
    \end{lstlisting}
    
\end{enumerate}


\end{document}
